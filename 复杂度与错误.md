## 复杂度

### 时间复杂度
时间复杂度用于**衡量一个算法执行所需时间随输入规模增长而变化的趋势**。
当数据规模恒定时，时间复杂度越大的算法运行时间通常会更长（可能有例外）。

#### 大O表示法 (Big O Notation)
通常一个算法的时间复杂度用大O表示法表示，常见的一些算法可能出现的复杂度有：$O(1)$, $O(\log N)$，$O(N)$, $O(N\log N)$，$O(N^2)$，$O(N^3)$，$O(2^N)$，$O(N!)$。
这里的 $\log N$ 是指 $\log_2 N$。

#### 如何计算时间复杂度？
* 忽略非最高次项和所有常数系数。比如，对于 $4n^2 + n + 5$，记为 $O(n^2)$。
* 重要的数据不能忽略。比如，对于 $4mn$，记为 $O(mn)$。

常见的多重循环比较方便计算，例如：
```
for i from 1 to n:
   for j from 1 to n:
```
结果就是 $O(n^2)$。

另一个例子是递归二叉树：
```
int fibonacci(n):
   if n <= 1: 
      return 1
   return fibonacci(n - 1) + fibonacci(n - 2)
```
复杂度为 $O(2^n)$。（这是近似，严格来讲会小一点）

如果想快速知道一个算法的时间复杂度可以直接网上搜，如果算法被魔改了就要自己数学推导。

### 空间复杂度
空间复杂度由于**衡量一个算法在运行过程中临时占用存储空间大小**。
同样用大O表示法表示。
这个概念在做算法题时的重要程度没有时间复杂度高，除非题目明显做了了内存限制（比如原本的512Mb变成了4Mb），否则我们大可以用**空间换时间**。
值得注意的是递归调用层数太多会极大增加空间占用，同时数组开太大（比如开到1e8或更大）也会增加空间占用。如果真的超出题目内存限制，就会获得 **MLE**。
关于空间换时间，举一个简单的例子。假设一个题目中的某个公式需要频繁调用任意一个数的阶乘，那如果每次计算都从 $1$ 乘到 $n$ 就会浪费巨额时间。
我们可以创建一个数组存储每个数对应的阶乘（通常题目会要求取模），这样就能将每次调用的时间复杂度从 $O(n)$ 降到 $O(1)$。

********************************************************************************

## 错误

### CE (Compile Error) —— 编译错误
* 语法错误。大部分IDE都可以检查出这类错误，除非你不编译直接提交。
* 提交时语言选择错误。一些平台的默认语言与你所用的不符，因而评测机无法编译。值得注意的是，如果你选择用C++17提交，但是代码中出现了C++20的专有语法，也会编译错误。
* 编译器因某些原因不兼容。比如你使用了`#include<bits/stdc++.h>`，但是某个OJ的编译器不允许使用，它就无法识别。
* 编译期资源申请超限。基本就是全局数组开太大导致的，比如开`int a[100000000][100000000]`。数组基本大于1e8就爆了。
* 使用了部分禁用函数。为了保证安全，一些有系统危险性的函数被禁用，比如`System("pause")。

### RE (Runtime Error) —— 运行时错误
* 数组越界。最常见的触发方式。记得开足数组大小并管理好下标。
* 解引用空指针。比如 `int *p = NULL`，接着试图赋值 `*p = 10`。系统找不到地址，于是出错。
* 栈溢出。可能是递归层数过多或反复在递归过程中反复申请大空间把栈空间撑爆。比如调用递归阶乘函数 ```fact(1000000)``` 或者无限递归。
* 另一种情况是局部数组开太大，这在一些IDE里可能会直接无法运行，比如VScode会显示为 “Segment fault” 。
* 试图除以 $0$。题目可能生成一些特殊数据会导致你的代码除以 $0$，这个时候你需要写 `if` 特判或用其他方法规避。
* 输入或输出不符合平台规范。不太可能出现，如果出现了就照着改。

### TLE (Time Limit Exceeded) —— 时间超限
* 算法本身不合适。用时间复杂度衡量可行性后再写代码，如果选择了不合适的算法基本不可能通过小优化解决，除非你一开始只想拿部分分。
* 容器导致超时。一些STL容器的函数带有不小的时间复杂度，如果错误估计则会导致隐性的超时。这通常要放在算法设计的考虑范畴内。
* 死循环。无限循环应该属于编写错误的一种，但它不会导致**WA**而是**TLE**。
* 没有关流或快读。有些题目的数据输入量非常大，如果你使用C++的 `std::cin` 可能会比较慢，这个时候需要在一开始手动关流：`std::ios::sync_with_stdio(false), std::cin.tie(0)`。如果习惯用快读就记得用。
* 使用了 `std::endl` 。建议改成 `'\n'`。

### MLE (Memory Limit Exceeded) —— 内存超限
* 申请过大的内存空间。你可能使用 `std::vector` 侥幸绕过了**CE**，紧接着被内存限制判负。
* 例如，试图开 `vector<vector<int>> vec(100000000, vector<int>(100000000))`，这个容器的大小达到了惊人的 **37252903GB**，或者近似 **35PB**，而一般题目的限制是 **256MB** 或 **512MB**。当然，也存在内存限制大幅缩水的题，这个时候就要精打细算了。
* 内存泄漏。不常见，通常是手动申请太多内存但不释放。大概率没人这样干。

### PE (Presentation Error) —— 格式错误
* 格式不对。没按照题目要求，或者有时候题目根本没有明说要求。遇到则进行以下尝试：
* 1. 去除行末空格。2. 添加或删除最后的换行。3. 如果是训练题，在网上搜搜有没有人遇到与你类似的情况。

### WA (Wrong Answer) —— 答案错误
太糟糕了！遇到WA了怎么办？
* 检查输出格式。有时候 **PE** 会被归类为 **WA**。
* 检查变量类型。有时候 `int` 会不够存储，而 `float` 会精度不够。需要改成 `long long` 和 `double`。极端情况下可能要使用 `unsigned long long` 甚至 `INT128_` 。
* 检查变量是否未初始化。C/C++中未初始化的局部变量可能有随机值。
* 检查浮点数精度。由于计算机的底层运算机制，计算高精度浮点数时可能会出错。在涉及四舍五入的计算时，为目标值加上一个无穷小值 `eps`（通常设成**1e-9**或**1e-12**）可以避免一些玄学问题。

如果以上基础问题都没发生，那大概率就是代码本身存在问题。你需要：
* 确认自己思路的正确性。重新仔细看一遍题目，或许你读错或理解错了呢？又或者你的算法真的不行？
* 寻找错误数据。通过人工制造数据，尤其是一些特殊数据或可能的针对性数据，检验代码是否正确。
* 手动debug。当找到错误数据且想不出来哪里出了错，可以在程序的关键位置输出相关的变量信息，看看是否与预期相符。
* 另一种方案：对拍。制造一个绝对正确但可能低效的代码，批量生产输入数据给两种代码，直到寻找到二者输出不相同的数据。具体做法不在这讲解。
